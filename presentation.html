<!DOCTYPE html>
<html>
  <head>
    <title>Parametrized Testing</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <style type="text/css">
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
      /* Two-column layout */
      .left-column {
        width: 50%;
        float: left;
      }
      .right-column {
        width: 50%;
        float: right;
      }
      .left-two-thirds {
        width: 66%;
        float: left;
      }
      .right-third {
        width: 30%;
        float: right;
      }
    </style>
  </head>
  <body>
  <textarea id="source">
class: center, middle

# Multiply your Testing Effectiveness with Parametrized Testing

Brian Okken

[@brianokken](https://twitter.com/brianokken)

Code and slides 

[github.com/okken/pycascades2020](https://github.com/okken/pycascades2020)

--

pytest & rocket stickers   
come see me after the talk
???
I'm so glad you are here.  
Thank you.

parametrized testing is one of the superpowers of pytest

* save you time
* both development time 
* and maintenance time. 


---

# Brian Okken

.left-column[
Work

<img src="images/r_s_logo.png" width="300">

Podcasts

<a href="https://testandcode.com">
<img src="images/testandcode.jpg" width="140"></a>
<a href="https://pythonbytes.fm">
<img src="images/pb.png" width="190"></a>
]
.right-column[
Book
 
<a href="https://t.co/AKfVKcdDoy?amp=1">
<img src="images/book.jpg" style="border-style: solid;" width="300">
</a>
]
???
I am Brian Okken. The O is soft. 
* an embedded C++ developer
* and a team lead 
* we make wireless communication test equipment

I'm also 
* the host of the Test & Code podcast.
* the co-host of Python Bytes
    * bringing Python news and headlines directly to your earbuds
* And I wrote a book
    * with input from a lot of really smart people

---

# Value of Tests

A passing test suite means:

* I didn't break anything that used to work.
* Future changes wonâ€™t break current features.
* The code is ready for users.
* I can refactor until I'm proud of the code.
* Code reviews can focus on team understanding and ownership.

Only works if:

* New features are tested with new tests.
* **Tests are easy and fast to write.**  <- *this is what we're focusing on*
???

* This is not just a "for your manager" slide. 
* You should know that a good robust test suite helps you
    * be proud of your code
    * have more fun
    * have less fear

* It's a bonus if the test cases are 
    * quick to write
    * easy to maintain

That's the part we are focusing on today

---

# Takeaways

* Why parametrization is useful

* Your choices 
    * function
    * fixture
    * `pytest_generate_tests`
    
* How to 
    * choose a technique
    * run subsets of test cases
    * use `pytest.param` for ids and markers
    * use `indirect` to intercept parameters with fixtures
    
???
* We're going to see the code for 3 ways to parametrize
    * function - use all the time
    * fixture  - once in a while
    * generate tests - very seldom
    
* Running subset of parametrizations
* The last two things may seem out of context
    * pytest.param
    * indirect
* You probably won't need them right away.
* But I want you to know about them so they don't 
    * seem mysterious when you do see them

---

# Parametrize vs Parameterize

**parameter** + **ize**

* paramet_erize_ (US)
* paramet_rize_ (UK)

`pytest` uses `parametrize`, the UK spelling.

I've tried to get them to change it.  
They don't want to.  
I've gotten over it. 

???
* parametrize

* There is no e between t and r
* Apparently both spellings are allowed in English

* Only one is allowed in pytest
    * I submitted a ticket to allow both
    * Core devs rejected it.
    * I've gotten over it. 

---

# Something to Test

`triangles.py`:
```python
def triangle_type(a, b, c):
    """
    Given three angles,
    return 'obtuse', 'acute', 'right', or 'invalid'.
    """
    angles = (a, b, c)
    if 90 in angles:
        return "right"
    if any([a > 90 for a in angles]):
        return "obtuse"
    if all([a < 90 for a in angles]):
        return "acute"
    if sum(angles) != 180:
        return "invalid"
```
Right ![](images/right_triangle.png),
Acute ![](images/acute_triangle.png),
Obtuse ![](images/obtuse_triangle.png),
???
* Some code to test
* Given 3 angles
    * Return a triangle type
        * Right if there's a 90 degree angle
        * Obtuse if one > 90
        * Acute if all < 90
* If you already know that, you rock
* I had to look it up.

* Also, there is at least one bug in the code

---

# without Parametrization

```python
def test_right():
    assert triangle_type(90, 60, 30) == "right"

def test_obtuse():
    assert triangle_type(100, 40, 40) == "obtuse"

def test_acute():
    assert triangle_type(60, 60, 60) == "acute"

def test_invalid():
    assert triangle_type(0, 0, 0) == "invalid"
```
```
$ pytest test_1.py
=================== test session starts ===================

test_1.py::test_right PASSED                        [ 25%]
test_1.py::test_obtuse PASSED                       [ 50%]
test_1.py::test_acute PASSED                        [ 75%]
test_1.py::test_invalid FAILED                      [100%]

=============== 1 failed, 3 passed in 0.03s ===============
```
???
* without parametrization, we might write something like this
* 4 outcomes, at least 4 test cases needed
* really, we need more
    * boundary values
    * floats
    * more invalid cases
    * but disregarding those for now
* these tests are simple. 1 line
* many tests will be more complicated 
    * in those cases
    * redundancy will be more painful

---
# pytest.ini

I wanted all the examples to include `--tb=no`, and `-v` for:
* hide tracebacks
* verbose: show the test names

So those are in a `pytest.ini` file:
```
[pytest]
addopts = --tb=no -v
markers =
    smoke : smoke tests
```
???
I wanted all the examples to include `--tb=no`, and `-v` for:
* hide tracebacks
* verbose: show the test names

So those are in a `pytest.ini` file

If this means nothing to you, don't worry about it

---
# Moving to one test (don't do this)
```python
def test_type():
    many_triangles = [
        (90, 60, 30, "right"),
        (100, 40, 40, "obtuse"),
        (60, 60, 60, "acute"),
        (0, 0, 0, "invalid"),
    ]
    for a, b, c, expected in many_triangles:
        assert triangle_type(a, b, c) == expected
```

```shell
$ pytest test_2.py
=================== test session starts ===================

test_2.py::test_type FAILED                         [100%]

==================== 1 failed in 0.03s ====================
```
???
If I wanted to replace my 4 tests  with 1 I could do this
* it's easier to extend now
* when everything passes, it seems fine

However
* there's really 4 test cases
* but pytest shows 1
* any failure fails everything
* what test case failed is a mystery without seeing the traceback

---
# Function Parametrization
```python
*@pytest.mark.parametrize( 'a, b, c, expected', [
    (90, 60, 30, "right"),
    (100, 40, 40, "obtuse"),
    (60, 60, 60, "acute"),
    (0, 0, 0, "invalid")])
*def test_func(a, b, c, expected):
    assert triangle_type(a, b, c) == expected
```
???
* This is the basic syntax for function parametrization
* the same 4 cases, one function
* the parameters can be in the decorator call, like this, but I'll
  switch to something more readable soon.
---
# Function Parametrization
```python
@pytest.mark.parametrize( 'a, b, c, expected', [
    (90, 60, 30, "right"),
    (100, 40, 40, "obtuse"),
    (60, 60, 60, "acute"),
    (0, 0, 0, "invalid")])
def test_func(a, b, c, expected):
    assert triangle_type(a, b, c) == expected
```
```shell 
$ pytest test_3.py
=================== test session starts ===================

test_3.py::test_func[90-60-30-right] PASSED         [ 25%]
test_3.py::test_func[100-40-40-obtuse] PASSED       [ 50%]
test_3.py::test_func[60-60-60-acute] PASSED         [ 75%]
test_3.py::test_func[0-0-0-invalid] FAILED          [100%]

=============== 1 failed, 3 passed in 0.03s ===============
```
???
* When we run it we see all the test cases now.
* so cool
* the long name, from test_ through the brackts, 
    * is called a node id
* I also call this a test case
---
# Function Parametrization

```python
*many_triangles = [
    (90, 60, 30, "right"),
    (100, 40, 40, "obtuse"),
    (60, 60, 60, "acute"),
    (0, 0, 0, "invalid")
]

*@pytest.mark.parametrize( 'a, b, c, expected', many_triangles)
def test_func(a, b, c, expected):
    assert triangle_type(a, b, c) == expected
```
Test cases moved to a variable
???
I find it easier to read if I name the list and move
the list definition out of the decorator call.

---
# Function Parametrization 

```python
*def many_triangles():
    return [ (90, 60, 30, "right"),
             (100, 40, 40, "obtuse"),
             (60, 60, 60, "acute"),
             (0, 0, 0, "invalid") ]

*@pytest.mark.parametrize( 'a, b, c, expected', many_triangles())
def test_func(a, b, c, expected):
    assert triangle_type(a, b, c) == expected
```
Test cases from a function
???
* Or from a function  
* Note that with this you can generate the test cases 
    * dynamically at test collection time
---
# Function Parametrization

```python
*def many_triangles():
    for t in [ (90, 60, 30, "right"),
               (100, 40, 40, "obtuse"),
               (60, 60, 60, "acute"),
               (0, 0, 0, "invalid")]:
*        yield t

*@pytest.mark.parametrize( 'a, b, c, expected', many_triangles())
def test_func(a, b, c, expected):
    assert triangle_type(a, b, c) == expected
```
Test cases from a generator
???
Or from a generator.
---
# Back to a List
```python
many_triangles = [
    (90, 60, 30, "right"),
    (100, 40, 40, "obtuse"),
    (60, 60, 60, "acute"),
    (0, 0, 0, "invalid")
]

@pytest.mark.parametrize('a, b, c, expected', many_triangles)
def test_func(a, b, c, expected):
    assert triangle_type(a, b, c) == expected

```
```
$ pytest test_7.py 
=================== test session starts ===================

test_7.py::test_func[90-60-30-right] PASSED         [ 25%]
test_7.py::test_func[100-40-40-obtuse] PASSED       [ 50%]
test_7.py::test_func[60-60-60-acute] PASSED         [ 75%]
test_7.py::test_func[0-0-0-invalid] FAILED          [100%]

=============== 1 failed, 3 passed in 0.03s ===============

```
???
* But let's go back to the list for now.
* Let's look at some tricks with running parametrized tests.
* We have a failure here.
---
# Run the last failing test case
```
*$ pytest --tb=short --lf test_7.py 
=================== test session starts ===================
collected 4 items / 3 deselected / 1 selected             
run-last-failure: rerun previous 1 failure

test_7.py::test_func[0-0-0-invalid] FAILED          [100%]

======================== FAILURES =========================
________________ test_func[0-0-0-invalid] _________________
test_7.py:14: in test_func
    assert triangle_type(a, b, c) == expected
E   AssertionError: assert 'acute' == 'invalid'
E     - acute
E     + invalid
============= 1 failed, 3 deselected in 0.03s =============
```
???
* We can use --lf to show the last failure
* and --tb=short to see a short version of the traceback
---
# Run test cases with 60 degree angles 
```
*$ pytest -k 60 test_7.py 
=================== test session starts ===================

test_7.py::test_func[90-60-30-right] PASSED         [ 50%]
test_7.py::test_func[60-60-60-acute] PASSED         [100%]

============= 2 passed, 2 deselected in 0.01s =============
```
???
Or we can run all test cases with 60 in the node id
---
# Run an individual test case 
```
*$ pytest test_7.py::test_func[0-0-0-invalid]
=================== test session starts ===================

test_7.py::test_func[0-0-0-invalid] FAILED          [100%]

==================== 1 failed in 0.03s ====================
```
???
Or run a specific test case
---
# Fixture Parametrization

Function: `test_7.py`
```python
@pytest.mark.parametrize('a, b, c, expected', many_triangles)
def test_func(a, b, c, expected):
    assert triangle_type(a, b, c) == expected

```

Fixture `test_8.py:` 
```python
*@pytest.fixture(params=many_triangles)
*def a_triangle(request):
*    return request.param

*def test_fix(a_triangle):
*    a, b, c, expected = a_triangle
    assert triangle_type(a, b, c) == expected
```

???
* The next technique for parametrization is fixture parametrization
* The basic syntax is easy enough
* The parameters are passed to the fixture decorator
* request.param will be filled with each tuple from many_triangles 
---
# Fixture Parametrization
```python
many_triangles = [
*    (90, 60, 30, "right"),
*    (100, 40, 40, "obtuse"),
*    (60, 60, 60, "acute"),
*    (0, 0, 0, "invalid")]

@pytest.fixture(params=many_triangles)
def a_triangle(request):
    return request.param

def test_fix(a_triangle):
    a, b, c, expected = a_triangle
    assert triangle_type(a, b, c) == expected
```
```
$ pytest test_8.py 
=================== test session starts ===================
*test_8.py::test_fix[a_triangle0] PASSED             [ 25%]
*test_8.py::test_fix[a_triangle1] PASSED             [ 50%]
*test_8.py::test_fix[a_triangle2] PASSED             [ 75%]
*test_8.py::test_fix[a_triangle3] FAILED             [100%]

=============== 1 failed, 3 passed in 0.03s ===============

```
???
* We have an issue here with the node names
* If we parametrize with objects, like tuples here, 
    * pytest doesn't try to come up with a good name 
    * it just names the parameters with a counter
* there's a few ways to fix it.

---
# Fixture Parametrization 
```python
many_triangles = [
*    (90, 60, 30, "right"),
*    (100, 40, 40, "obtuse"),
*    (60, 60, 60, "acute"),
*    (0, 0, 0, "invalid") ]

@pytest.fixture(params=many_triangles,
*                ids=['right', 'obtuse', 'acute', 'invalid'])
def a_triangle(request):
    return request.param

def test_fix(a_triangle):
    a, b, c, expected = a_triangle
    assert triangle_type(a, b, c) == expected
```

```
$ pytest test_9.py 
=================== test session starts ===================
*test_9.py::test_fix[right] PASSED                   [ 25%]
*test_9.py::test_fix[obtuse] PASSED                  [ 50%]
*test_9.py::test_fix[acute] PASSED                   [ 75%]
*test_9.py::test_fix[invalid] FAILED                 [100%]
=============== 1 failed, 3 passed in 0.03s ===============
```
???
ids allows us to pass in either a list of identifiers

---
# Fixture Parametrization
```python
many_triangles = [
     (90, 60, 30, "right"),
     (100, 40, 40, "obtuse"),
     (60, 60, 60, "acute"),
     (0, 0, 0, "invalid") ]

@pytest.fixture(params=many_triangles, 
*                ids=str)  # or repr
def a_triangle(request):
    return request.param

def test_fix(a_triangle):
    a, b, c, expected = a_triangle
    assert triangle_type(a, b, c) == expected

```
```
$ pytest test_10.py 
=================== test session starts ===================
*test_10.py::test_fix[(90, 60, 30, 'right')] PASSED  [ 25%]
*test_10.py::test_fix[(100, 40, 40, 'obtuse')] PASSED [ 50%]
*test_10.py::test_fix[(60, 60, 60, 'acute')] PASSED  [ 75%]
*test_10.py::test_fix[(0, 0, 0, 'invalid')] FAILED   [100%]
=============== 1 failed, 3 passed in 0.03s ===============

```
???
* or a function that can take one of the parametrizations 
* and return a string
* often, str or repr are fine to pass in

---
# Fixture Parametrization 
```python
*def idfn(a_triangle):
*    a, b, c, expected = a_triangle
*    return f'{a}-{b}-{c}-{expected}'

*@pytest.fixture(params=many_triangles, ids=idfn)
def a_triangle(request):
    return request.param

def test_fix(a_triangle):
    a, b, c, expected = a_triangle
    assert triangle_type(a, b, c) == expected
```

```
$ pytest test_11.py 
=================== test session starts ===================
*test_11.py::test_fix[90-60-30-right] PASSED         [ 25%]
*test_11.py::test_fix[100-40-40-obtuse] PASSED       [ 50%]
*test_11.py::test_fix[60-60-60-acute] PASSED         [ 75%]
*test_11.py::test_fix[0-0-0-invalid] FAILED          [100%]
=============== 1 failed, 3 passed in 0.03s ===============
```
???
* You can also use a lambda function
* But I often like to just write an id function.

* when would you use Fixture over Function
* if doing work to set up each fixture value
* if you are already using a fixture for some of the work and thats
    * the bit that needs to be rerun for multiple setup states

---
# pytest_generate_tests()
```python
*def pytest_generate_tests(metafunc):
*    if "gen_triangle" in metafunc.fixturenames:
*        metafunc.parametrize("gen_triangle",
*                             many_triangles,
*                             ids=idfn)

def test_gen(gen_triangle):
    a, b, c, expected = gen_triangle
    assert triangle_type(a, b, c) == expected
```

```
$ pytest test_12.py 
=================== test session starts ===================

test_12.py::test_gen[90-60-30-right] PASSED         [ 25%]
test_12.py::test_gen[100-40-40-obtuse] PASSED       [ 50%]
test_12.py::test_gen[60-60-60-acute] PASSED         [ 75%]
test_12.py::test_gen[0-0-0-invalid] FAILED          [100%]

=============== 1 failed, 3 passed in 0.03s ===============
```
???
* third technique -> the hook function pytest_generate_tests

Benefits:
- generate parametrizations based on more info, 
    * metafunc has a lot of introspection

---
# metafunc

From [docs.pytest.org/en/latest/reference.html#metafunc](https://docs.pytest.org/en/latest/reference.html#metafunc)

* Metafunc objects are passed to the pytest_generate_tests hook.  
* They help to inspect a test function and to generate tests according to 
    * test configuration 
    * or values specified in the class or module where a test function is defined.
???
For instance, 
* you could generate the parameter list based on command like flags 
* or other configuration.
* or based on the presence of other fixtures besides the one you are parmetrizing

---
# test.param
`test_12.py:`
```python
many_triangles = [
     (90, 60, 30, "right"),
     (100, 40, 40, "obtuse"),
     (60, 60, 60, "acute"),
     (0, 0, 0, "invalid") 
]
```
`test_13.py:`
```python
*smoke = pytest.mark.smoke

many_triangles = [
*    pytest.param(90, 60, 30, "right", marks=smoke),
*    pytest.param(100, 40, 40, "obtuse", marks=smoke),
    (90, 60, 30, "right"),
*    pytest.param(0, 0, 0, "invalid", id='zeros'),
]
```
???
* Parametrizations can be modified with pytest.param
* You can add markers to individual test cases
* You can change the identifier

---
# test.param

```python
smoke = pytest.mark.smoke

many_triangles = [
    pytest.param(90, 60, 30, "right", marks=smoke),
    pytest.param(100, 40, 40, "obtuse", marks=smoke),
    (90, 60, 30, "right"),
    pytest.param(0, 0, 0, "invalid", id='zeros'),
]
```
```
*$ pytest -m smoke test_13.py 
=================== test session starts ===================
test_13.py::test_func[90-60-30-right] PASSED        [ 50%]
test_13.py::test_func[100-40-40-obtuse] PASSED      [100%]
============= 2 passed, 4 deselected in 0.01s =============
```
```
*$ pytest -k zeros test_13.py 
=================== test session starts ===================
test_13.py::test_func[zeros] PASSED                 [100%]
============= 1 passed, 3 deselected in 0.01s =============
```
---
# indirect parameter
`test_14.py:`
```python
@pytest.fixture()
*def expected(request):
    if request.param == 'obtuse':
        print('\nthis is one of the obtuse cases')
    return request.param


@pytest.mark.parametrize('a, b, c, expected', many_triangles,
*                         indirect=['expected'])
def test_func(a, b, c, expected):
    assert triangle_type(a, b, c) == expected
```

The parameter value goes through a fixture before making
it to the test, an "indirect" route.

???
* indirect
* default is False.
* Can be a list of fixture names 
* or True to mean all fixtures are indirect.
* useful for when you need to do some work based on
  the value of one of the parameters.
* I don't use this much
---

# More test cass

```python
many_triangles = [
    (  1, 1, 178, "obtuse"), # big angles
    ( 91, 44, 45, "obtuse"), # just over 90
    (0.01, 0.01, 179.98, "obtuse"), # decimals 

    (90, 60, 30, "right"), # check 90 for each angle
    (10, 90, 80, "right"),
    (85,  5, 90, "right"),

    (89, 89,  2, "acute"), # just under 90
    (60, 60, 60, "acute"),

    (0, 0, 0, "invalid"),     # zeros
    (61, 60, 60, "invalid"),  # sum > 180
    (90, 91, -1, "invalid"),  # negative numbers
]
``` 

For more on test case selection:
* [Test & Code 38](https://testandcode.com/38) : Prioritize software tests with RCRCRC
* [Test & Code 39](https://testandcode.com/39) : equivalence partitioning, boundary value analysis, decision tables
???
* in this instance, 4 test cases really isn't enough
* this is a more realistic set of test cases
* parametrization 
    * easy to have a more full set of test cases 
    * without much extra work 
    * without much increased maintenance costs

---
# Review

```python
@pytest.mark.parametrize('a, b, c, expected', many_triangles)
def test_func(a, b, c, expected):
    assert triangle_type(a, b, c) == expected
```
```python
@pytest.fixture(params=many_triangles, ids=idfn)
def a_triangle(request):
    return request.param

def test_fix(a_triangle):
    a, b, c, expected = a_triangle
    assert triangle_type(a, b, c) == expected
```
```python
def pytest_generate_tests(metafunc):
    if "gen_triangle" in metafunc.fixturenames:
        metafunc.parametrize("gen_triangle",
                             many_triangles, ids=idfn)

def test_gen(gen_triangle):
    a, b, c, expected = gen_triangle
    assert triangle_type(a, b, c) == expected
```

---
# Choosing a Technique

Guidelines

1. **function parametrization**
    * use this if you can
2. **fixture parametrization**
    * if doing work to set up each fixture value
    * if running multiple test against the same set of "setup states"
3. **pytest_generate_tests()**
    * if list is based on passed in parameters or external resources
      or other introspection not available to other methods


---
# Combining Techniques

You can have multiple parametrizations for a test function.

* can have multiple `@pytest.mark.parametrize()` decorators on a test function.
* can parameterize multipe fixtures per test
* can use pytest_generate_tests() to parametrize multiple parameters
* can use a combination of techniques 
* can blow up into lots and lots of test cases very fast
---

# Resources

.left-two-thirds[
* [Python Testing with pytest](https://t.co/AKfVKcdDoy?amp=1) 
    * The fastest way to get super productive with pytest
* pytest docs on 
    * [parametrization, in general](https://docs.pytest.org/en/latest/parametrize.html) 
    * [function parametrization](https://docs.pytest.org/en/latest/parametrize.html#pytest-mark-parametrize)
    * [fixture parametrization](https://docs.pytest.org/en/latest/fixture.html#fixture-parametrize)
    * [pytest_generate_tests](https://docs.pytest.org/en/latest/parametrize.html#basic-pytest-generate-tests-example)
    * [indirect](http://doc.pytest.org/en/latest/example/parametrize.html#apply-indirect-on-particular-arguments)
* podcasts
    * [Test & Code](https://testandcode.com) 
    * [Python Bytes](https://pythonbytes.fm)
    * [Talk Python](https://talkpython.fm)
* slack community: [Test & Code Slack](https://testandcode.com/slack) 
* Twitter: [@brianokken](https://twitter.com/brianokken), [@testandcode](https://twitter.com/testandcode)
* This code, and markdown for slides, on [github.com/okken/pycascades2020](https://github.com/okken/pycascades2020)
]
.right-third[
<a href="https://t.co/AKfVKcdDoy?amp=1">
<img src="images/book.jpg" style="border-style: solid;" width="200">
</a>
]
    </textarea>
    <script src="remark-latest.min.js" type="text/javascript">
    </script>
    <script type="text/javascript">
     var slideshow = remark.create({
         highlightLanguage: 'python',
         /*highlightStyle: 'idea', */
         highlightLines: true,
      });
    </script>
  </body>
</html>
